# Тестирование программного обеспечения
# Лабораторная работа 2. Интеграционное тестирование
Выполнил: *Можаев Илья, Университет ИТМО, ТЕСТПО 1.2*

## 1. Выбор проекта
Проект выполняется на языке Python. Для проведения интеграционного тестирования используется фрагмент модуля диагностики сетевого оборудования провайдера (в реальности модуль содержит больше классов и функций, для данной задачи вынесены требуемые). В данной задаче проект выполняет функцию мониторинга трафика на порту пользователя интернет-провайдера.

Проект состоит из нескольких модулей, основные из которых:
* packet.py – запускает обработчик.
* packet_scan_handler.py – основной класс-координатор, который получает номер пользователя, обращается к базе данных для получения его свитча и номера порта, подключается к свитчу и запрашивает статистику пакетов на порту, чтобы передать в именованный канал (PIPE).
* database_manager.py – модуль для работы с реальной БД (MySQL).
* base_network_device.py, base_switch.py, L2_switch.py – иерархия классов для взаимодействия с сетевым оборудованием по telnet, выполнения команд и парсинга вывода.
* commands.py – словари с регулярными выражениями для свитчей.
* my_exception.py – пользовательские исключения.
* packet.sh – инициализующий bash-скрипт, читающий данные из pipe и выводящий их в реальном времени, в текущем интеграционном тестировании он использоваться не будет.

Код исходного модуля расположен в папке bin/ проекта ([GitHub](https://github.com/theLoneCheetah/network_user_packet_scan/tree/main/bin)).

## 2. Анализ взаимодействий
В данном проекте между собой взаимодействуют несколько компонент: обработчик, именованный канал, база данных, менеджер оборудования. Ключевыми точками интеграции можно назвать следующие:
1. Получение данных пользователя из БД: PacketScanHandler запрашивает у DatabaseManager, который подключается к реальной БД, информацию о свитче и порте по номеру пользователя. Без этого диагностика невозможна.
2. Подключение к свитчу: PacketScanHandler создаёт объект L2Switch, который подключается к реальном свитчу и выполняет подготовку его командного интерфейса. Без этого диагностика невозможна.
3. Выполнение команды на свитче и получение статистики: метод get_packets_port() объекта L2Switch получает статистику пакетов, парсит ответ и возвращает число байт. Ключевой момент сбора данных.
4. Передача данных через именованный канал: PacketScanHandler пишет в PIPE строку с текущими значениями, bash-скрипт читает и обновляет экран. Влияет на корректность отображения.
5. Обработка ошибок на разных уровнях: при недоступности свитча, отсутствии записи в БД или других проблемах должны генерироваться и обрабатываться соответствующие исключения. Обеспечивает отказоустойчивость модуля.

## 3. Подготовка тестового окружения
Первоначальный проект жёстко привязан к реальной БД и сетевому оборудованию и может быть запущен только из локальной сети провайдера. Для проведения интеграционных тестов создаётся упрощённое окружение с помощью mock-объектов, заменяющее внешние зависимости:
* База данных: вместо реальной БД MySQL реализуется её mock-версия FakeDatabaseManager, имитирующая запрос с целью получения свитча и порта.
* Свитч: вместо реального оборудования используется класс-заглушка FakeL2Switch, имитирующий получение данных трафика с порта на основе случайных значений.
* Именованный канал PIPE: в тестах используется временный файл test_output.txt, заменяющий собой канал. Это удобно также с точки зрения запуска на различных ОС, т.к. FIFO из оригинального проекта не поддерживается на Windows.

В отдельных тестах используются собственные mock-объекты для определённого поведения. Для изменения атрибутов объектов используется фикстура monkeypatch, для отслеживания вывода в консоль - фикстура capsys, для работы с временной директорией, в которой работает pytest, для создания в ней временного файла - фикстура tmp_path.

## 4. Написание тестов
Все тесты написаны и запускаются с использованием фреймворка pytest. Они должны быть изолированы, воспроизводимы и не требовать доступа к реальной сети или БД, поэтому их основная задача - проверять корректность взаимодействия некоторых методов взаимосвязанных объектов и грамотную обработку возникающих исключений.

Для проведения интеграционного тестирования были написаны следующие тесты:
* test_get_switch_port_success - проверяет, что PacketScanHandler правильно получает данные о свитче и порте через DatabaseManager. Для этого используются описанные ранее mock-классы.
* test_no_user_in_db - проверяет, что при возникновении ошибки при обработке запроса к БД (отсутствия пользователя) PacketScanHandler корректно обрабатывает вызванное исключение. Для этого используется отдельный mock-класс менеджера БД для имитации ошибки поиска пользователя.
* test_switch_unavailable - проверяет, что при ошибке на этапе подключения к свитчу (например, недоступность свитча) PacketScanHandler корректно обрабатывает вызванное исключение. Для этого отдельный mock-класс имитирует ошибку подключения к свитчу.
* test_get_packets_port - проверяет, грамотно ли PacketScanHandler получает от менеджера свитча ожидаемые данные о статистике пакетов.
* test_full_integration - выполняет имитацию интеграции всего процесса: получение данных от фейковой БД, получение трафика на порту от фейкового свитча, перевод в мегабиты с использованием метода проекта и запись данных в тестовый файл.

## 5. Результаты запуска тестов
Запустить файл с помощью фреймворка pytest можно командой `python3 -m pytest test_packet_scan.py`. Результат запуска показан на скриншоте ниже.

<img width="1485" height="358" alt="image" src="https://github.com/user-attachments/assets/21785fdf-2930-4e7e-8310-ec42dfd9581a" />

Как видно из вывода, четыре из пяти тестов завершились успешно, один упал с ошибкой AssertionError. Вывод наглядно показывает, что в проекте присутствует недочёт: попытка удаления объекта-менеджера свитча _L2_manager, который может не быть создан на этот момент. Из-за этого вывод, отловленный с помощью фикстуры capsys, при проверке с помощью assert оказывается неполным. Это говорит о недостаточной отладке исходного проекта и необходимости внесения изменений.

## 6. Выводы
1. Все пять написанных тестов выполнили проверку взаимодействия основных компонентов проекта, а также обработку исключений.
2. Четыре успешно завершившихся теста показывают, что основной обработчик корректно получает данные от менеджера БД и менеджера свитча, форматирует их и передаёт в именованный канал, а также обрабатывает некоторые исключения.
3. Один из тестов, завершившийся с ошибкой assert, показывает, что не все возможные исключения в исходном обработчике отлажены корректно. Это очень важный найденный нюанс, который позволит доработать недочёты проекта.
4. Для проведения независимого тестирования потребовалось создать несколько тестовых заглушек, что говорит о большой роли привязки к реальной системе провайдера. Дальнейшее тестирование лучше производить, непосредственно подключаясь к реальной БД и реальному сетевому оборудованию.
5. Интеграционное тестирование при грамотной отладке и поиске взаимосвязей компонентов проекта позволяет диагностировать многие критически важные места работы, а также выявить потенциальные проблемы.
